{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"api/","text":"API \u00b6 Api Referenece","title":"API"},{"location":"api/#api","text":"Api Referenece","title":"API"},{"location":"concepts/","text":"Concepts \u00b6","title":"Concepts"},{"location":"concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/actions/","text":"Actions \u00b6","title":"Actions"},{"location":"concepts/actions/#actions","text":"","title":"Actions"},{"location":"concepts/attributes/","text":"Attributes \u00b6","title":"Attributes"},{"location":"concepts/attributes/#attributes","text":"","title":"Attributes"},{"location":"concepts/attributes/data-sources/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"concepts/attributes/data-sources/#data-sources","text":"","title":"Data Sources"},{"location":"concepts/attributes/details/","text":"Data Sources \u00b6","title":"Details"},{"location":"concepts/attributes/details/#data-sources","text":"","title":"Data Sources"},{"location":"concepts/attributes/formatters/","text":"Formatters \u00b6","title":"Formatters"},{"location":"concepts/attributes/formatters/#formatters","text":"","title":"Formatters"},{"location":"concepts/attributes/graph/","text":"Graphing \u00b6","title":"Graphing"},{"location":"concepts/attributes/graph/#graphing","text":"","title":"Graphing"},{"location":"concepts/attributes/relationships/","text":"Relationships \u00b6","title":"Relationships"},{"location":"concepts/attributes/relationships/#relationships","text":"","title":"Relationships"},{"location":"concepts/attributes/table/","text":"Data Sources \u00b6","title":"Table Columns"},{"location":"concepts/attributes/table/#data-sources","text":"","title":"Data Sources"},{"location":"concepts/models/","text":"Models \u00b6 Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON. Characteristics \u00b6 A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them. Plain JSON Object \u00b6 Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism. Immutable \u00b6 Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences. Typed \u00b6 Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel Working with Models \u00b6 There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Models"},{"location":"concepts/models/#models","text":"Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON.","title":"Models"},{"location":"concepts/models/#characteristics","text":"A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them.","title":"Characteristics"},{"location":"concepts/models/#plain-json-object","text":"Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism.","title":"Plain JSON Object"},{"location":"concepts/models/#immutable","text":"Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences.","title":"Immutable"},{"location":"concepts/models/#typed","text":"Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel","title":"Typed"},{"location":"concepts/models/#working-with-models","text":"There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Working with Models"},{"location":"concepts/models/editors/","text":"Model Editors \u00b6 ModelEditorFactory useValueChange Hook - Model and eventData Recursive ModelEditors in ModelEditors","title":"Editors"},{"location":"concepts/models/editors/#model-editors","text":"ModelEditorFactory useValueChange Hook - Model and eventData Recursive ModelEditors in ModelEditors","title":"Model Editors"},{"location":"concepts/models/model-util/","text":"Model Util \u00b6 Example createAllValue createAllArray discussion about normalization of this into { get, indexOf, removeAt, etc } createAllMap discussion about normalization of this into { get, indexOf, removeAt, etc }","title":"Model Util"},{"location":"concepts/models/model-util/#model-util","text":"Example createAllValue createAllArray discussion about normalization of this into { get, indexOf, removeAt, etc } createAllMap discussion about normalization of this into { get, indexOf, removeAt, etc }","title":"Model Util"},{"location":"concepts/plugins/","text":"Plugins \u00b6 Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few. Use \u00b6 The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values (like Molten's initializer plugins ) to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point. Observable \u00b6 The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Plugins"},{"location":"concepts/plugins/#plugins","text":"Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few.","title":"Plugins"},{"location":"concepts/plugins/#use","text":"The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values (like Molten's initializer plugins ) to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point.","title":"Use"},{"location":"concepts/plugins/#observable","text":"The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Observable"},{"location":"concepts/plugins/config/","text":"Configuration \u00b6 The Plugins mechanism supplies a way registering objects for use in different mechanisms. The Config mechanism supplies a single location where these plugins can supply configurable options without each interface having to make its own options mechanism. Getting Config Values \u00b6 To use the Config option in your plugin, invoke the get( rsource, key, defaultValue ) method: import { Config } from `@leverege/plugins` const opt1 = Config . get ( 'myProject.MyPlugin' , 'option1' , 12 ) In general, you should avoid get Config options at the time you javascript is loaded, but instead delay until when the option is needed. This will avoid any ordering issues between intialization and usage of the Config options. Setting Config Values \u00b6 To set the Config option, use set( rsource, key, value ) method: import { Config } from `@leverege/plugins` Config . set ( 'myProject.MyPlugin' , 'option1' , 42 ) On Molten startup, the LoadConfig plugin will take all options stored in Molten's config object at the path 'plugins/config' and set them on the Plugin's Config object.","title":"Config"},{"location":"concepts/plugins/config/#configuration","text":"The Plugins mechanism supplies a way registering objects for use in different mechanisms. The Config mechanism supplies a single location where these plugins can supply configurable options without each interface having to make its own options mechanism.","title":"Configuration"},{"location":"concepts/plugins/config/#getting-config-values","text":"To use the Config option in your plugin, invoke the get( rsource, key, defaultValue ) method: import { Config } from `@leverege/plugins` const opt1 = Config . get ( 'myProject.MyPlugin' , 'option1' , 12 ) In general, you should avoid get Config options at the time you javascript is loaded, but instead delay until when the option is needed. This will avoid any ordering issues between intialization and usage of the Config options.","title":"Getting Config Values"},{"location":"concepts/plugins/config/#setting-config-values","text":"To set the Config option, use set( rsource, key, value ) method: import { Config } from `@leverege/plugins` Config . set ( 'myProject.MyPlugin' , 'option1' , 42 ) On Molten startup, the LoadConfig plugin will take all options stored in Molten's config object at the path 'plugins/config' and set them on the Plugin's Config object.","title":"Setting Config Values"},{"location":"concepts/plugins/factories/","text":"Factories \u00b6 The Factory concept encapsulates the \"I have a object, give me a way to do X with it\". This 'way' can be represented by a Class, a function or object, and is defined by the plugin point making use of the factory. What the intent of this mechanism is ( the X ), is left up to the plugin point. Examples include but are in no way limited to: Finding a processor for an incoming message object Presenting a React editor or view for an object Exporting an XML node that represents the object Finding a formatting object to convert the object to a string Configuring a cache mechanism to use a different backend Finding and configuring a color calculator for objects In order to find or lookup the appropriate handling mechanism from the Factory, the object must have a type associated with it. By default, the factories look for the 'type' field on the object and use it to look up the mechanism registered in the factory. Tip If you are unhappy with a registered factory object (like an Editor for a Model), you can replace the install one with you own. It will be use in place of the original. Make sure your object implements all the requirements defined by the plugin point. Creation and Registration \u00b6 For a plugin point to use a Factory, it should use the createFactory( type, options, throwError = false ) method to obtain and/or create it. const factory = Plugins . createFactory ( 'myProject.MyLookupType' , { name : 'default' , pluginKey : 'processor' , strategy : Plugins . ALL } ) The first argument identifies the plugin point type that the Factory is using in its lookups, the second object is the options used to configure the factory: Option Field Default Description name default The name of the Factory. This is used to cache the factory so it can be returned from a repeated createFactory() or getFactory() call. pluginKey plugin The key in the registered plugin that defines the item the Factory will use. pluginKeyType type The type key name used by Factory.create() and Factory.get() when finding a factory item. strategy Plugins.ALL This determines how to treat the item found in create() before it is returned. See below for strategy descriptions. defaultObject null If no look up is found for a type, this object will be used registry null The default objects in the lookup To register a Plugins for use in the factory describe above: const myFactoryPlugin = { type : 'myObjectType' , processor : ( obj ) => { /* do something */ } } Plugins . add ( `myProject.MyLookupType` , myFactoryPlugin ) In this case, the type defines what kind of object this processor will be used for. Because the Factory options specified processor as the pluginKey , the actual object is registered using that key. If the factory is invoked like this const msg = { type : 'myObjectType' , /* more values */ } const result = factory . create ( msg ) the myFactoryPlugin.processor( msg ) will be invoked and its result returned. Because the stategy is ALL and the processor is a function, the function will be invoked will all parameters given to the create() . Different Strategy objects can be set on a Factory to allow different behaviors to occur. When create( obj, ...rest ) is invoked, the strategies will behave in the following ways: Strategy Result Plugins.ALL This is the default strategy. If the registered item is a function, it will be invoked with f( obj, ...rest ) and the result returned. If the registered item is a Class, new Clzz( obj, ...args ) will be returned. Plugins.NONE If the registered item is a function, it will be invoked with no options. If the registered item is a Class, new Clzz( ) will be returned. Plugins.ARGS If the registered item is a function, it will be invoked with f( ...rest ) and the result returned. If the registered item is a Class, new Clzz( ...args ) will be returned. Plugins.MERGE If the registered item is a function, it will be invoked with f( { model : msg, ...rest } ) and the result returned. If the registered item is a Class, new Clzz( { model : msg, ...args } ) will be returned. The Plugins.mergeStrategy() call can be used to create a merge strategy that will use a different key. Plugins.LOOKUP In this case, the registered object is simply returned Plugins.reactStrategy( React, propKey = 'model' ) This strategy will call React.createElement() with the registered item as the component function or class. The ...rest object will be supplied as props to the component. If propKey is a string, the obj object will be given as a prop as well, using the propKey as the prop name. function A custom function( factory, registeredItem, typeOrObject, props ) can be set as the strategy object as well. Dynamic Factories \u00b6 The Factory mechanism used in the plugin library is backed by @leverege/factory and augmented to include automatic registration and deregistration of plugins as they are added and removed. The factory mechanism can be used independently of Plugins as well - See @leverege/factory .","title":"Factories"},{"location":"concepts/plugins/factories/#factories","text":"The Factory concept encapsulates the \"I have a object, give me a way to do X with it\". This 'way' can be represented by a Class, a function or object, and is defined by the plugin point making use of the factory. What the intent of this mechanism is ( the X ), is left up to the plugin point. Examples include but are in no way limited to: Finding a processor for an incoming message object Presenting a React editor or view for an object Exporting an XML node that represents the object Finding a formatting object to convert the object to a string Configuring a cache mechanism to use a different backend Finding and configuring a color calculator for objects In order to find or lookup the appropriate handling mechanism from the Factory, the object must have a type associated with it. By default, the factories look for the 'type' field on the object and use it to look up the mechanism registered in the factory. Tip If you are unhappy with a registered factory object (like an Editor for a Model), you can replace the install one with you own. It will be use in place of the original. Make sure your object implements all the requirements defined by the plugin point.","title":"Factories"},{"location":"concepts/plugins/factories/#creation-and-registration","text":"For a plugin point to use a Factory, it should use the createFactory( type, options, throwError = false ) method to obtain and/or create it. const factory = Plugins . createFactory ( 'myProject.MyLookupType' , { name : 'default' , pluginKey : 'processor' , strategy : Plugins . ALL } ) The first argument identifies the plugin point type that the Factory is using in its lookups, the second object is the options used to configure the factory: Option Field Default Description name default The name of the Factory. This is used to cache the factory so it can be returned from a repeated createFactory() or getFactory() call. pluginKey plugin The key in the registered plugin that defines the item the Factory will use. pluginKeyType type The type key name used by Factory.create() and Factory.get() when finding a factory item. strategy Plugins.ALL This determines how to treat the item found in create() before it is returned. See below for strategy descriptions. defaultObject null If no look up is found for a type, this object will be used registry null The default objects in the lookup To register a Plugins for use in the factory describe above: const myFactoryPlugin = { type : 'myObjectType' , processor : ( obj ) => { /* do something */ } } Plugins . add ( `myProject.MyLookupType` , myFactoryPlugin ) In this case, the type defines what kind of object this processor will be used for. Because the Factory options specified processor as the pluginKey , the actual object is registered using that key. If the factory is invoked like this const msg = { type : 'myObjectType' , /* more values */ } const result = factory . create ( msg ) the myFactoryPlugin.processor( msg ) will be invoked and its result returned. Because the stategy is ALL and the processor is a function, the function will be invoked will all parameters given to the create() . Different Strategy objects can be set on a Factory to allow different behaviors to occur. When create( obj, ...rest ) is invoked, the strategies will behave in the following ways: Strategy Result Plugins.ALL This is the default strategy. If the registered item is a function, it will be invoked with f( obj, ...rest ) and the result returned. If the registered item is a Class, new Clzz( obj, ...args ) will be returned. Plugins.NONE If the registered item is a function, it will be invoked with no options. If the registered item is a Class, new Clzz( ) will be returned. Plugins.ARGS If the registered item is a function, it will be invoked with f( ...rest ) and the result returned. If the registered item is a Class, new Clzz( ...args ) will be returned. Plugins.MERGE If the registered item is a function, it will be invoked with f( { model : msg, ...rest } ) and the result returned. If the registered item is a Class, new Clzz( { model : msg, ...args } ) will be returned. The Plugins.mergeStrategy() call can be used to create a merge strategy that will use a different key. Plugins.LOOKUP In this case, the registered object is simply returned Plugins.reactStrategy( React, propKey = 'model' ) This strategy will call React.createElement() with the registered item as the component function or class. The ...rest object will be supplied as props to the component. If propKey is a string, the obj object will be given as a prop as well, using the propKey as the prop name. function A custom function( factory, registeredItem, typeOrObject, props ) can be set as the strategy object as well.","title":"Creation and Registration"},{"location":"concepts/plugins/factories/#dynamic-factories","text":"The Factory mechanism used in the plugin library is backed by @leverege/factory and augmented to include automatic registration and deregistration of plugins as they are added and removed. The factory mechanism can be used independently of Plugins as well - See @leverege/factory .","title":"Dynamic Factories"},{"location":"concepts/plugins/layout/","text":"Layout \u00b6 Sometimes, especially for UI Plugins, the Plugins need to be ordered and arranged into a tree like structure. This can be true of actions in a menu, creators in a selector, and other such mechanisms. The Layout is supplied as a common way to do this ordering. To use it: import { Layout } from '@leverege/plugins' const tree = Layout . create ( arrayOfItems /*, { buildTree : true } */ ) This create call will look at every item in the array for a layout object. This object can have the following options: Field Default Description sort item.name or item.type or '_z' This string is used to organize the objects into priorities. Items sorted with small sort values are higher in the list, so an 'a' will occur before a 'z' in sort order. group [] An array of strings representing groups. In a tree, items that share the group path will end up in the same node in hierarchy. groupNames [] The name of the group elements, used for human consumption. Only one item will contribute this value (the first one defining it) groupIcons [] The icon (either url or font icon) of the groups, used for human consumption. Only one item will contribute this value (the first one defining it) If create() is called with the buildTree option set to false, and array of objects containing { sort, group, groupKey, groupNames, groupIcons, item } will be returned. If buildTree is not set or is true, the array will be turned into a tree, where the root and groups in the tree look like: { type : 'layoutNode' , name , icon , items : [ ] } The items array will contain items from the original array and other layout nodes, created in order to support the hierarchy.","title":"Layout"},{"location":"concepts/plugins/layout/#layout","text":"Sometimes, especially for UI Plugins, the Plugins need to be ordered and arranged into a tree like structure. This can be true of actions in a menu, creators in a selector, and other such mechanisms. The Layout is supplied as a common way to do this ordering. To use it: import { Layout } from '@leverege/plugins' const tree = Layout . create ( arrayOfItems /*, { buildTree : true } */ ) This create call will look at every item in the array for a layout object. This object can have the following options: Field Default Description sort item.name or item.type or '_z' This string is used to organize the objects into priorities. Items sorted with small sort values are higher in the list, so an 'a' will occur before a 'z' in sort order. group [] An array of strings representing groups. In a tree, items that share the group path will end up in the same node in hierarchy. groupNames [] The name of the group elements, used for human consumption. Only one item will contribute this value (the first one defining it) groupIcons [] The icon (either url or font icon) of the groups, used for human consumption. Only one item will contribute this value (the first one defining it) If create() is called with the buildTree option set to false, and array of objects containing { sort, group, groupKey, groupNames, groupIcons, item } will be returned. If buildTree is not set or is true, the array will be turned into a tree, where the root and groups in the tree look like: { type : 'layoutNode' , name , icon , items : [ ] } The items array will contain items from the original array and other layout nodes, created in order to support the hierarchy.","title":"Layout"},{"location":"concepts/plugins/refinement/","text":"Plugin Refinement \u00b6 There are many situations where the Plugins registered at a given plugin point are further analyzed before being used. An example of this are Actions that are presented in a toolbar or context menu. In this situation, there are many Action plugins registered, but we only want to use the Actions that desired to be seen on a particular screen or when the target object is of a particular type. This refinement can occur in different ways depending on the plugin point, but two common paradigms often occur: matches objects and handles() functions. Match vs Handles Ultimately, how plugins are selected for use depends on the plugin point. There are situations when both matches and handles() are used. When this occurs, it is usually an indication of broad stroke filter(the matches) and then a finer grain mechanism to really decide whether or not the plugin should used. An example of this is Actions in a toolbar, where the matches is used to identify the client and particular toolbar, and the handles() is use to indicate that it can be used if a particular object is selected in the context given to handles(). The client will feed different contexts to the toolbars based on which objects are selected in table, map, list or other UI mechanism. Matches Paradigm \u00b6 Sometimes a plugin point will use the Matches paradigme to filter Plugins. This is often used as static, cacheable filter for all possible things that might show up in a plugin point. This paradigm has two sides: one advertised by the plugin point indicating what and/or where it is, and one on the Plugin that indicates its specific requirements. In order for a Plugin to be used, all the required fields in the Plugin's matches object must be met by the plugin point's matchContext . For example: export default MyAction { matches : { use : 'actionBar' , client : 'MyScreen' } // ... } This plugin is specifying that it should be used only when the plugin point specifies that the plugins are being used for an actionBar and the plugin point is in client called MyScreen . How plugin point specifies this filtered set of plugins can vary, but a simple example is to use the filter parameter on Plugins.get() import { Plugins , Context } from '@leverege/plugin' const matchContext = { use : 'actionBar' , client : 'MyScreen' , mobile : false , otherParam : 'yes' } const actions = Plugins . get ( 'Actions' , Context . createMatch ( matchContext ) ) In this particualr case, MyAction's matches.use would be compared against matchContext.use , and matches.client would be compared to matchContext.client . Since both fields match, the Action would pass the filter an be used. The other fields in the matchContext are unused in the case of MyAction, but other plugins might use them. It is important for the plugin point creator to document the contents of the matchContext. Some common matchContext parameters are represent here, but any keys can be supplied by the plugin point. Field Example client The overal type of screen or client. clientType A refinement of the client. Is sometimes the same as client mobile Is this client being used for a mobile presentation objectType The type of object being represented path The relationship path relationship A Relationship object Example Note In the above case, the Plugins.get() is not caching its results so the filter will occur every time. This is for example purposes only, and a Plugin View should really be used instead. The Context.createMatch() is a convenience function that calls plg => Match.isMatch( clientMatch, plg.matches ) Match Syntax \u00b6 The Match.isMatch( context, matches ) function has several rules it follows. If matches is Result null return true. All requirements are met. Array isMatch() is called for each element in the array. If any ony return true, the outer isMatch() will return true as well. function The result of calling matches( context ) will be returned. (it should return true or false) Object Each key in matches is evaluated against the context . If any one returns false, false is returned. Otherwise return true. See below for Field rules. else return false. Tip In general, it is best to use the Array or the Object when ever possible and avoid the complicated function at the field level. However, setting matches to a function and console logging the context is a quick way to see debug the matchesContext being used to evaluate your Plugin. When isMatch compares the fields in the matches object to the context object, it will use the following rules to evaluate each field key. The matches[field] and context[field] maybe both be arrays, in which cases each item in the matches is compared to each value in the context , and if any result in a true evaluation, the field will be considered matching. (For this description, V is the field value supplied in the matches object from the Plugin, and CV is the value of the field in the matchContext. R is used to indicate a recursive invokation of this rule.) If the field value V Result is an Array Return true if R( V[n], CV) is true equals CV return true * return true if CV is non-null Starts with '!' return true if V.substring(1) is not equal to CV Starts with '>', '>=', '<', '<=' returns true if mathematically CV is greater than, greater than or equal to, less then, less than or equal to the V minues the comparator null return true if CV is null or undefined Object if V.not exists, return false if R( V.not, CV) returns true. If V.and exists, return R( V.and, CV) . Otherwise return true function return result of V( context, CV ) return false Handles Paradigm \u00b6 In this paradigm, the Plugin will have a handle( cxt ) method that can return either true or false. If true, the Plugin should be used. This is very similar to Matches paradigm, though the intent is different, and these two paradigms are often used together on the same plugin point. Where the Matches paradigm may statically filter the set of Plugins down to all possible ones that might be used in this particular plugin point, the handles( cxt ) is meant to look deeper at what is happening in that particular case to determine if the plugin can or wants participate. The context object cxt supplied to this method contains entries that represent the current state of the plugin point: are certain objects checked, is the user right clicking on a particular item, is an item in a list selected, etc. As an example, a Contextual Action Menu plugin might want to work in a table of objects of type \"vehicle\", but only want that vehicle is in an alert state and the user has permissions to send an sms message to its owner. The Matches might match against client equaling 'TableView' and its path equaling 'dealer.vehicles', while the handles( cxt ) would check that the target object is a vehicle and the user is permissioned to send an sms. Context \u00b6 The plugins library includes a Context class meant to aid in the evaluation of the handles() context object. On primary support supplied is in regards to the target of the given context. It can be one object or many. There could also be a secondary target, or many secondary targets. It is up to your Plugin to decide when it should participate using the given context. In the case of a Action, some can support many targets, like perhaps a bulk remove. Some may require a single primary and a single secondary target, like a pair A to B. Some may allow many targets and many secondary targets. And some may not require targets at all, but some other field in the context. The following methods in Context can help your Plugin evaluate this context object. The following target methods below will look at the 'target' key in the Context object. Normally, objects are expected to have a { type : <objectType> } field. When this is not possible, the context can be constructed with a targetType field that indicates the type of targets in the target list. Method Description getTarget( cxt ) Returns the first object in the target field getTargets( cxt ) Returns an Array of objects in the target field getTargetTypes( cxt ) Returns an Array of objectTypes in the target field isTargetOfType( cxt, type, only = true ) Returns true if the target is of the given type. When isOnly is true, this will also return false when there are more than one target. getTargetOfType( cxt, type, only = true ) Returns the object or null in the target if it is of the given type. When isOnly is true, this will also return null when there are more than one target. hasTargetsOfType( cxt, type, arrayCondition = 'any ) This will return true if there are any targets in the list of the specified type. Possible options for arrayCondition inclue 'any', 'onlyOne', 'one', and 'all'. Using 'onlyOne' means there is only one target in the list and it is of the given type. Using 'one' means there is only one target in the list of the type. Using 'all' means all trargets must be of the specified type. getTargetsOfType( cxt, type, arrayCondition = 'any ) This is like hasTargetsOfType() but an array of the targets are actually returned. For secondary target evaluation, the same methods above exist but with the addition of 'Secondary' in the method name: getSecondaryTargetTypes , isSecondaryTargetOfType , getSecondaryTargetOfType , hasSecondaryTargetsOfType , getSecondaryTargetsOfType . These methods will use the fields called secondaryTarget and `secondaryTargetType . These methods are also available in a generic form where you can supply the keys to evaluate: getObject , getObjects , getOfType , getObjectTypes , isObjectOfType , getObjectOfType , hasObjectsOfType .","title":"Refinement"},{"location":"concepts/plugins/refinement/#plugin-refinement","text":"There are many situations where the Plugins registered at a given plugin point are further analyzed before being used. An example of this are Actions that are presented in a toolbar or context menu. In this situation, there are many Action plugins registered, but we only want to use the Actions that desired to be seen on a particular screen or when the target object is of a particular type. This refinement can occur in different ways depending on the plugin point, but two common paradigms often occur: matches objects and handles() functions. Match vs Handles Ultimately, how plugins are selected for use depends on the plugin point. There are situations when both matches and handles() are used. When this occurs, it is usually an indication of broad stroke filter(the matches) and then a finer grain mechanism to really decide whether or not the plugin should used. An example of this is Actions in a toolbar, where the matches is used to identify the client and particular toolbar, and the handles() is use to indicate that it can be used if a particular object is selected in the context given to handles(). The client will feed different contexts to the toolbars based on which objects are selected in table, map, list or other UI mechanism.","title":"Plugin Refinement"},{"location":"concepts/plugins/refinement/#matches-paradigm","text":"Sometimes a plugin point will use the Matches paradigme to filter Plugins. This is often used as static, cacheable filter for all possible things that might show up in a plugin point. This paradigm has two sides: one advertised by the plugin point indicating what and/or where it is, and one on the Plugin that indicates its specific requirements. In order for a Plugin to be used, all the required fields in the Plugin's matches object must be met by the plugin point's matchContext . For example: export default MyAction { matches : { use : 'actionBar' , client : 'MyScreen' } // ... } This plugin is specifying that it should be used only when the plugin point specifies that the plugins are being used for an actionBar and the plugin point is in client called MyScreen . How plugin point specifies this filtered set of plugins can vary, but a simple example is to use the filter parameter on Plugins.get() import { Plugins , Context } from '@leverege/plugin' const matchContext = { use : 'actionBar' , client : 'MyScreen' , mobile : false , otherParam : 'yes' } const actions = Plugins . get ( 'Actions' , Context . createMatch ( matchContext ) ) In this particualr case, MyAction's matches.use would be compared against matchContext.use , and matches.client would be compared to matchContext.client . Since both fields match, the Action would pass the filter an be used. The other fields in the matchContext are unused in the case of MyAction, but other plugins might use them. It is important for the plugin point creator to document the contents of the matchContext. Some common matchContext parameters are represent here, but any keys can be supplied by the plugin point. Field Example client The overal type of screen or client. clientType A refinement of the client. Is sometimes the same as client mobile Is this client being used for a mobile presentation objectType The type of object being represented path The relationship path relationship A Relationship object Example Note In the above case, the Plugins.get() is not caching its results so the filter will occur every time. This is for example purposes only, and a Plugin View should really be used instead. The Context.createMatch() is a convenience function that calls plg => Match.isMatch( clientMatch, plg.matches )","title":"Matches Paradigm"},{"location":"concepts/plugins/refinement/#match-syntax","text":"The Match.isMatch( context, matches ) function has several rules it follows. If matches is Result null return true. All requirements are met. Array isMatch() is called for each element in the array. If any ony return true, the outer isMatch() will return true as well. function The result of calling matches( context ) will be returned. (it should return true or false) Object Each key in matches is evaluated against the context . If any one returns false, false is returned. Otherwise return true. See below for Field rules. else return false. Tip In general, it is best to use the Array or the Object when ever possible and avoid the complicated function at the field level. However, setting matches to a function and console logging the context is a quick way to see debug the matchesContext being used to evaluate your Plugin. When isMatch compares the fields in the matches object to the context object, it will use the following rules to evaluate each field key. The matches[field] and context[field] maybe both be arrays, in which cases each item in the matches is compared to each value in the context , and if any result in a true evaluation, the field will be considered matching. (For this description, V is the field value supplied in the matches object from the Plugin, and CV is the value of the field in the matchContext. R is used to indicate a recursive invokation of this rule.) If the field value V Result is an Array Return true if R( V[n], CV) is true equals CV return true * return true if CV is non-null Starts with '!' return true if V.substring(1) is not equal to CV Starts with '>', '>=', '<', '<=' returns true if mathematically CV is greater than, greater than or equal to, less then, less than or equal to the V minues the comparator null return true if CV is null or undefined Object if V.not exists, return false if R( V.not, CV) returns true. If V.and exists, return R( V.and, CV) . Otherwise return true function return result of V( context, CV ) return false","title":"Match Syntax"},{"location":"concepts/plugins/refinement/#handles-paradigm","text":"In this paradigm, the Plugin will have a handle( cxt ) method that can return either true or false. If true, the Plugin should be used. This is very similar to Matches paradigm, though the intent is different, and these two paradigms are often used together on the same plugin point. Where the Matches paradigm may statically filter the set of Plugins down to all possible ones that might be used in this particular plugin point, the handles( cxt ) is meant to look deeper at what is happening in that particular case to determine if the plugin can or wants participate. The context object cxt supplied to this method contains entries that represent the current state of the plugin point: are certain objects checked, is the user right clicking on a particular item, is an item in a list selected, etc. As an example, a Contextual Action Menu plugin might want to work in a table of objects of type \"vehicle\", but only want that vehicle is in an alert state and the user has permissions to send an sms message to its owner. The Matches might match against client equaling 'TableView' and its path equaling 'dealer.vehicles', while the handles( cxt ) would check that the target object is a vehicle and the user is permissioned to send an sms.","title":"Handles Paradigm"},{"location":"concepts/plugins/refinement/#context","text":"The plugins library includes a Context class meant to aid in the evaluation of the handles() context object. On primary support supplied is in regards to the target of the given context. It can be one object or many. There could also be a secondary target, or many secondary targets. It is up to your Plugin to decide when it should participate using the given context. In the case of a Action, some can support many targets, like perhaps a bulk remove. Some may require a single primary and a single secondary target, like a pair A to B. Some may allow many targets and many secondary targets. And some may not require targets at all, but some other field in the context. The following methods in Context can help your Plugin evaluate this context object. The following target methods below will look at the 'target' key in the Context object. Normally, objects are expected to have a { type : <objectType> } field. When this is not possible, the context can be constructed with a targetType field that indicates the type of targets in the target list. Method Description getTarget( cxt ) Returns the first object in the target field getTargets( cxt ) Returns an Array of objects in the target field getTargetTypes( cxt ) Returns an Array of objectTypes in the target field isTargetOfType( cxt, type, only = true ) Returns true if the target is of the given type. When isOnly is true, this will also return false when there are more than one target. getTargetOfType( cxt, type, only = true ) Returns the object or null in the target if it is of the given type. When isOnly is true, this will also return null when there are more than one target. hasTargetsOfType( cxt, type, arrayCondition = 'any ) This will return true if there are any targets in the list of the specified type. Possible options for arrayCondition inclue 'any', 'onlyOne', 'one', and 'all'. Using 'onlyOne' means there is only one target in the list and it is of the given type. Using 'one' means there is only one target in the list of the type. Using 'all' means all trargets must be of the specified type. getTargetsOfType( cxt, type, arrayCondition = 'any ) This is like hasTargetsOfType() but an array of the targets are actually returned. For secondary target evaluation, the same methods above exist but with the addition of 'Secondary' in the method name: getSecondaryTargetTypes , isSecondaryTargetOfType , getSecondaryTargetOfType , hasSecondaryTargetsOfType , getSecondaryTargetsOfType . These methods will use the fields called secondaryTarget and `secondaryTargetType . These methods are also available in a generic form where you can supply the keys to evaluate: getObject , getObjects , getOfType , getObjectTypes , isObjectOfType , getObjectOfType , hasObjectsOfType .","title":"Context"},{"location":"concepts/plugins/views/","text":"Views \u00b6 As mentioned earlier, the Plugins.get( type, filter ) call can return a filtered set of plugins of a given type. Sometimes, however, these plugins are evaluated and organized into a more complicated structure that allows for easier and quicker access. This is where the View comes into play. The View will watch the Plugin mechanisms for Plugins that are added and removed, and mark its view as dirty when appropriate. When the View is nexted ask for its value, it can either recalculate the value or return a cached one. For a plugin point to use a Factory, it should use the createView( type, options, throwError = false ) method to obtain and/or create it. const view = Plugins . createView ( 'myProject.MyLookupType' , options ) The first argument identifies the plugin point type that the View is using , the second object is the options used to configure the factory: Option Field Default Description name default The name of the View. This is used to cache the View so it can be returned from a repeated createFactory() or getFactory() call. sort defaultSort This defines the sort function used to sort the plugins. By default, the sort function uses a string sorting mechanism on the 'sort' key, but alternates functions can be used. If this is 'byNumber', a sort using a number will be installed. filter null The filter used to prune plugins from the View. If processor is supplied, this is not used. processor null A function that, if supplied, this is invoked with an Array of sorted plugins. The result of this function is returned from View.get() . If this is not supplied, the filter options will be used. If a processor is not supplied, view.get() will return an array of plugins, sorted and filtered according to those options. If the processor is given, the result from the processor defines the shape of the return value of view.get() . When a Plugin of the View's type is added or removed, the view is marked as dirty and is recalculated vi processor or filter on the next invokation of view.get() .","title":"Views"},{"location":"concepts/plugins/views/#views","text":"As mentioned earlier, the Plugins.get( type, filter ) call can return a filtered set of plugins of a given type. Sometimes, however, these plugins are evaluated and organized into a more complicated structure that allows for easier and quicker access. This is where the View comes into play. The View will watch the Plugin mechanisms for Plugins that are added and removed, and mark its view as dirty when appropriate. When the View is nexted ask for its value, it can either recalculate the value or return a cached one. For a plugin point to use a Factory, it should use the createView( type, options, throwError = false ) method to obtain and/or create it. const view = Plugins . createView ( 'myProject.MyLookupType' , options ) The first argument identifies the plugin point type that the View is using , the second object is the options used to configure the factory: Option Field Default Description name default The name of the View. This is used to cache the View so it can be returned from a repeated createFactory() or getFactory() call. sort defaultSort This defines the sort function used to sort the plugins. By default, the sort function uses a string sorting mechanism on the 'sort' key, but alternates functions can be used. If this is 'byNumber', a sort using a number will be installed. filter null The filter used to prune plugins from the View. If processor is supplied, this is not used. processor null A function that, if supplied, this is invoked with an Array of sorted plugins. The result of this function is returned from View.get() . If this is not supplied, the filter options will be used. If a processor is not supplied, view.get() will return an array of plugins, sorted and filtered according to those options. If the processor is given, the result from the processor defines the shape of the return value of view.get() . When a Plugin of the View's type is added or removed, the view is marked as dirty and is recalculated vi processor or filter on the next invokation of view.get() .","title":"Views"},{"location":"config/","text":"This describes the values in the Molten Confg.js file. Show/Hide the Layout Controller Path plugins/config/LayoutViewerSelector Allows visibility control of the layout button in GroupScreen and ItemInfoScreen. { allowEditing : | } for example: { allowEditing : \"Installer, Admin\" } Would allow user in the persona of Installer or Admin to see the buttons plugins/config/mapBoxPosition Sets default position and zoom. selectedRezoomThreshold: Indicates at what range (or less ) the view should recenter/zoom in on the selected object. selectedZoom : target zoom when selection occurs and rezoom threshold is exceeded. ( Negative one means dont zoom ) pathOptions : an object where the keys are the blueprint paths to allow customization of selectedRezoom options. { center : [ -77.1902656, 39.1081595 ], zoom : 18, selectedRezoomThreshold : 12, // if we re beyond this range, selection will cause rezoom/center selectedZoom : 18, // this is the target range to go to on selection. pathOptions : { building : { selectedRezoomThreshold : 10, selectedZoom : 18 } } } UserManagement / ResourceUser Screen Under plugins/config/ResourceUsers, the following keys can be set to change properties: Key Default userSelectorUsernameLabel Email or Username* userSelectorUsernameHint Enter Email or Username userSelectorUsernameInstructions Enter user's email or username and hit enter or next to continue. addUserTitle Add User editUserTitle Edit User addUserOkay Next editUserUpdate Update allowCreateUser true allowInviteUser true inviteEmailLabel Email* inviteEmailHint Enter Email createEmailLabel Account Email* createEmailHint ex. johnsmith@example.com createUsernameLabel Username createUsernameHint Enter Username activateEmailLabel Account Email* createNameLabel Name* createNameHint ex. John Smith createPhoneLabel Phone Number createPhoneHint ex. (555) 555-5555 createPasswordLabel Password createPasswordHint Enter password createConfirmPasswordLabel Confirm Password createConfirmPasswordHint Re-enter password screenIcon addDialogIcon editDialogIcon removeUserDialogIcon 404 / LostScreen Under plugins/config/LostScreen, the following keys can be set to change properties: Key Default Description title Oops! The title to put on the page message We couldn't find this page - our apologies! The sub text to display to the user button Let's find our way The label of the button on the \u2018home\u2019 link link '/' The location to take the user when the button is pressed image fa fa-meh-o The font icon or image url to display. This can also be an array of font icons and image urls. If it is an Array, one will randomly be selected and used. These images are supplied as good initial resource.s LostScreen : { image : [ 'https://molten-ui-assets.storage.googleapis.com/404-UFO.png', 'https://molten-ui-assets.storage.googleapis.com/404-Earth.png', 'https://molten-ui-assets.storage.googleapis.com/404-Page.png', 'https://molten-ui-assets.storage.googleapis.com/404-Ghost.png' ] } NetworkOffline Under plugins/config/NetworkOffline, the following keys can be set to change properties: Key Default Description message Your Network connection has been lost. The message to display when network connection is lost. icon fa fa-exclamation-triangle The font icon class or image url to display with the text, when the connection is lost. BlueprintActions Under plugins/config/BlueprintActions, the following keys can be set to change properties: Key Default Description updateIcon fa fa-pencil fa-fw The font icon class or image url to display for a blueprint update action. createIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint create action. bulkCreateIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint bulk create action. removeIcon fa fa-trash fa-fw The font icon class or image url to display for a blueprint remove action. No Data/No Search Results Views Under plugins/config/ where is one of ListDataViewer or TableDataViewer the following keys can be set to change the no data/no search results views: Key Default Description noDataMessage The class found in molten at: src/screens/shared/group/noData/NoDataView.jsx The string or React Component/Function to render when there is no data in the table/list Under plugins/config/NoDataView the following keys can be set to configure the NoDataView that is used by default Key Default Description Key Default Description noDataTitle the name of the blueprint Can be overridden by a string in the blueprint or attribute noDataBody Looks like there's nothing here, try creating something! Can be overridden by a string in the blueprint or attribute noDataIcon https://molten-ui-assets.storage.googleapis.com/no-data.svg Can be overridden by a string in the blueprint or attribute noDataIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute noDataDocLink null Can be overridden by a string in the blueprint or attribute noSearchResultsTitle We couldn't find any matches for that Can be overridden by a string in the blueprint or attribute noSearchResultsBody Please try searching for another item Can be overridden by a string in the blueprint or attribute noSearchResultsIcon https://molten-ui-assets.storage.googleapis.com/no-search-results.svg Can be overridden by a string in the blueprint or attribute noSearchResultsIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute","title":"Index"},{"location":"docs/","text":"","title":"Index"},{"location":"docs/custom-data/","text":"Adding Custom Data \u00b6 A common need in molten is the consumption of data that is external to the leverege platform. That data might be stored locally in files, accessible through a 3 rd party API, or elsewhere. Assuming the data is roughly structured as a group of items with individual items within it, the process for consuming and displaying this data on custom pages within a molten application are as follows: Create actions classes that mirror the Group and Item Actions Create a DataSource object to make those actions available Add custom Atrribute plugins to let the ui configure viewing the data Make a custom route that uses GroupScreen to view the data Add custom actions to CRUD the data (optional) Customize the search features (optional) This section of the documentation will serve as a tutorial for how to perform these actions and, in particular, how to set up a pet shop demo in molten that manages a list of pets","title":"Adding Custom Data"},{"location":"docs/custom-data/#adding-custom-data","text":"A common need in molten is the consumption of data that is external to the leverege platform. That data might be stored locally in files, accessible through a 3 rd party API, or elsewhere. Assuming the data is roughly structured as a group of items with individual items within it, the process for consuming and displaying this data on custom pages within a molten application are as follows: Create actions classes that mirror the Group and Item Actions Create a DataSource object to make those actions available Add custom Atrribute plugins to let the ui configure viewing the data Make a custom route that uses GroupScreen to view the data Add custom actions to CRUD the data (optional) Customize the search features (optional) This section of the documentation will serve as a tutorial for how to perform these actions and, in particular, how to set up a pet shop demo in molten that manages a list of pets","title":"Adding Custom Data"},{"location":"docs/custom-data/actions/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Creating Custom Actions"},{"location":"docs/custom-data/actions/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"docs/custom-data/actions/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"docs/custom-data/attributes/","text":"Pets have 3 attributes (besides their id): Name, Age, and Position. To be able to view these attributes in a table, update form, or creation form, Attribute plugins must be created for them. Attributes plugins have a few required fields, namely: name - The name of the Attribute, which is used to look it up along with objectType to perform common operations objectType - The type of object this Attribute is relevant to, which is used along with name to look it up to perform common operations valueType - The type of the attribute, which can be anything, but common types include strings , numbers , integers , geoPoints , geoJson , and Timestamp . get - This function is used by display and update mechanisms to get the current value of this attribute given an instance of the objectType it pertains to and some context displayName - A field of the Attribute used to display the attribute in lists for configuration or default titles Name Attribute Age Attribute Position Attribute Setup { name : 'name' , objectType : 'petApi.pet' , valueType : 'string' , get : ( data , cxt ) => { return data ? . name }, displayName : 'Name' } { name : 'age' , objectType : 'petApi.pet' , valueType : 'number' , get : ( data , cxt ) => { return data ? . age }, displayName : 'Age' } { name : 'geoPosition' , objectType : 'petApi.pet' , valueType : 'geoPoint' , get : ( data , cxt ) => { return data ? . position }, displayName : 'Position' } molten . addPlugin ( 'Attribute' , NameAttribute ) molten . addPlugin ( 'Attribute' , AgeAttribute ) molten . addPlugin ( 'Attribute' , PositionAttribute )","title":"Making Custom Attributes"},{"location":"docs/custom-data/data-source/","text":"The second step of consuming custom data in your molten application is creating a DataSource. More general DataSource documentation can be found here For our use case, of creating a list of pets, the DataSource might look like this: import { GlobalState } from '@leverege/ui-redux' import PetsActions from './PetsActions' import PetActions from './PetActions' export default class PetDataSource { dataSource () { return 'petApi.pets' } getData ( objRef ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ objRef . id ] } getActions ( objRef ) { if ( objRef ? . id ) { return new PetActions ( { item : objRef , id : objRef ? . id } ) } return new PetsActions () } } Notice that in the getActions function we are returning instances of our PetActions and PetsActions classes as implemented in the previous step.","title":"Creating a DataSource"},{"location":"docs/custom-data/molten-actions/","text":"Beyond basic list functionality, it's easy in molten to add actions to Create, Update, and Delete items in your list if those are things your API supports. Below is the code for basic actions to perform these operations continuing the pet shop example. Create Action \u00b6 Plugin Create Pet Component Shared Create/Edit Form File CreateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import CreatePet from '../views/CreatePet' // given a Relationship instance, make a create action that can be installed into molten export default relationship => ( { id : 'action.pet.CreateItem' , name : 'Create Pet Item' , layout : { sort : 'item.add' }, handles : cxt => true , appearance : ( ) => { return { name : 'Create Pet' , icon : Config . get ( 'BlueprintActions' , 'createIcon' , 'https://storage.googleapis.com/molten-ui-assets/create-action.png' ) } }, perform : ( { context } ) => { const { clientProps : { actions }, reloadData } = context Dialogs . show ( { component : CreatePet , props : { reloadData , actions , relationship } } ) } } ) File CreatePet.jsx import React from 'react' import { Dialog , Toast } from '@leverege/ui-elements' import { GlobalState } from '@leverege/ui-redux' import CreateEditForm from './CreateEditForm' export default function CreatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . create ( value ) ) Toast . success ( 'Successfully Created Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Create Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Create Pet\" submitText = \"Submit\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } } Update Action \u00b6 Plugin Update Pet Component Shared Create/Edit Form File UpdateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config , Context } from '@leverege/plugin' import { DataSources } from '@leverege/ui-attributes' import UpdatePet from '../views/UpdatePet' // given a Relationship instance, make an update action that can be installed into molten export default relationship => ( { id : 'blueprint.action.pet.UpdateItem' , name : 'Update Pet Item' , layout : { sort : 'item.update' }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , 'petApi.pet' ) return ! ( targets == null || targets . length === 0 || targets . length > 1 ) }, appearance : ( ) => { return { name : 'Update Pet' , icon : Config . get ( 'BlueprintActions' , 'updateIcon' , 'https://storage.googleapis.com/molten-ui-assets/update-action.png' ) } }, perform : ( { context } ) => { const { reloadData } = context const target = Context . getTargetOfType ( context , 'petApi.pet' ) const actions = DataSources . getActions ( target ) Dialogs . show ( { component : UpdatePet , props : { reloadData , actions , relationship , value : target ? . data } } ) } } ) File UpdatePet.jsx import React from 'react' import { GlobalState } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' import CreateEditForm from './CreateEditForm' export default function UpdatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . update ( value ) ) Toast . success ( 'Successfully Updated Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Update Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Update Pet\" submitText = \"Update\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } } Delete Action \u00b6 Plugin Delete Pet Component File DeleteAction.js import { Context , Config } from '@leverege/plugin' import { Dialogs } from '@leverege/ui-elements' import DeletePet from '../views/DeletePet' export default ( relationship , { objectType , name , namePlural } ) => { const { path , attribute } = relationship const sectionName = ` ${ name } Actions` return { id : `action. ${ path } .DeleteItem` , name : `Delete ${ namePlural } Items` , layout : { sort : 'item.zzz' , sectionName }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , objectType ) return ! ( targets == null || targets . length === 0 ) }, appearance : ( { context , action } ) => { const targets = Context . getTargetsOfType ( context , objectType ) const num = targets . length return { name : num < 2 ? `Delete ${ name } ` : `Delete ${ num } ${ namePlural } ` , icon : Config . get ( 'PetActions' , 'deleteIcon' , 'https://storage.googleapis.com/molten-ui-assets/delete-action.png' ), disabled : num === 0 } }, perform : ( { context } ) => { const { clientProps : { actions , targetKey } } = context const targets = Context . getTargetsOfType ( context , objectType ) if ( targets . length === 0 ) { return } Dialogs . show ( { component : DeletePet , props : { targets , actions , attribute , isItem : false , selectionKey : targetKey , } } ) } } } File DeletePet.jsx /* eslint-disable no-await-in-loop */ import React from 'react' import { DataSources } from '@leverege/ui-attributes' import { GlobalState , Selection } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' /** * Removes the userIds from the given action. */ async function onRemove ( { data } ) { // Get parameters const { targets , selectionKey , onClose } = data const num = targets . length if ( num === 0 ) { onClose () return } // Try to remove users let success = 0 let failure = 0 let err = null for ( let n = 0 ; n < num ; n ++ ) { try { const tgt = targets [ n ] const actions = DataSources . getActions ( tgt ) await GlobalState . dispatch ( actions . delete () ) success ++ if ( selectionKey ) { GlobalState . dispatch ( Selection . remove ( selectionKey , tgt . id ) ) } } catch ( error ) { failure ++ if ( err == null ) { err = error } // eslint-disable-next-line no-console console . error ( error ) } } // Successfully removed if ( failure === 0 ) { Toast . success ( ` ${ success === 1 ? '' : num } Pet ${ num === 1 ? '' : 's' } Deleted` ) } else if ( success === 0 ) { Toast . error ( [ `Failed to Delete ${ failure === 1 ? '' : num } Pet` , err . message ] ) } else { Toast . warn ( [ `Deleted ${ success } / ${ num } Pet. Failed to delete ${ failure } .` , err . message ] ) } onClose () } /** * Remove users dialog. */ export default function DeletePet ( props ) { // Get parameters const { onClose , show , targets } = props const num = targets ? . length || 0 const title = num < 2 ? 'Pet' : ` ${ num } Pets` const button = 'Delete' const titleType = 'Delete' const extra = `This will permanently delete the ${ title } and cannot be undone.` // Render component return ( < Dialog . Question show = { show } eventData = { props } title = { ` ${ titleType } ${ title } ?` } message = { `Are you sure you want to DELETE ${ num } Pet ${ num === 1 ? '' : 's' } ? ${ extra } ` } okay = { button } okayVariant = \"primaryDestructive\" onCancel = { onClose } onOkay = { onRemove } /> ) } Setup \u00b6 File PluginSetup.js import DeleteAction from './DeleteAction' import CreateAction from './CreateAction' import UpdateAction from './UpdateAction' import Relationship from '../../../src/dataSource/Relationship' const objectType = 'petApi.pet' const name = 'Pet' const namePlural = 'Pets' exports . install = ( molten ) => { const relationship = new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' , } ) molten . addPlugin ( 'Action' , DeleteAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , CreateAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , UpdateAction ( relationship , { objectType , name , namePlural } ) ) }","title":"Adding CRUD Actions"},{"location":"docs/custom-data/molten-actions/#create-action","text":"Plugin Create Pet Component Shared Create/Edit Form File CreateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import CreatePet from '../views/CreatePet' // given a Relationship instance, make a create action that can be installed into molten export default relationship => ( { id : 'action.pet.CreateItem' , name : 'Create Pet Item' , layout : { sort : 'item.add' }, handles : cxt => true , appearance : ( ) => { return { name : 'Create Pet' , icon : Config . get ( 'BlueprintActions' , 'createIcon' , 'https://storage.googleapis.com/molten-ui-assets/create-action.png' ) } }, perform : ( { context } ) => { const { clientProps : { actions }, reloadData } = context Dialogs . show ( { component : CreatePet , props : { reloadData , actions , relationship } } ) } } ) File CreatePet.jsx import React from 'react' import { Dialog , Toast } from '@leverege/ui-elements' import { GlobalState } from '@leverege/ui-redux' import CreateEditForm from './CreateEditForm' export default function CreatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . create ( value ) ) Toast . success ( 'Successfully Created Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Create Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Create Pet\" submitText = \"Submit\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } }","title":"Create Action"},{"location":"docs/custom-data/molten-actions/#update-action","text":"Plugin Update Pet Component Shared Create/Edit Form File UpdateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config , Context } from '@leverege/plugin' import { DataSources } from '@leverege/ui-attributes' import UpdatePet from '../views/UpdatePet' // given a Relationship instance, make an update action that can be installed into molten export default relationship => ( { id : 'blueprint.action.pet.UpdateItem' , name : 'Update Pet Item' , layout : { sort : 'item.update' }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , 'petApi.pet' ) return ! ( targets == null || targets . length === 0 || targets . length > 1 ) }, appearance : ( ) => { return { name : 'Update Pet' , icon : Config . get ( 'BlueprintActions' , 'updateIcon' , 'https://storage.googleapis.com/molten-ui-assets/update-action.png' ) } }, perform : ( { context } ) => { const { reloadData } = context const target = Context . getTargetOfType ( context , 'petApi.pet' ) const actions = DataSources . getActions ( target ) Dialogs . show ( { component : UpdatePet , props : { reloadData , actions , relationship , value : target ? . data } } ) } } ) File UpdatePet.jsx import React from 'react' import { GlobalState } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' import CreateEditForm from './CreateEditForm' export default function UpdatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . update ( value ) ) Toast . success ( 'Successfully Updated Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Update Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Update Pet\" submitText = \"Update\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } }","title":"Update Action"},{"location":"docs/custom-data/molten-actions/#delete-action","text":"Plugin Delete Pet Component File DeleteAction.js import { Context , Config } from '@leverege/plugin' import { Dialogs } from '@leverege/ui-elements' import DeletePet from '../views/DeletePet' export default ( relationship , { objectType , name , namePlural } ) => { const { path , attribute } = relationship const sectionName = ` ${ name } Actions` return { id : `action. ${ path } .DeleteItem` , name : `Delete ${ namePlural } Items` , layout : { sort : 'item.zzz' , sectionName }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , objectType ) return ! ( targets == null || targets . length === 0 ) }, appearance : ( { context , action } ) => { const targets = Context . getTargetsOfType ( context , objectType ) const num = targets . length return { name : num < 2 ? `Delete ${ name } ` : `Delete ${ num } ${ namePlural } ` , icon : Config . get ( 'PetActions' , 'deleteIcon' , 'https://storage.googleapis.com/molten-ui-assets/delete-action.png' ), disabled : num === 0 } }, perform : ( { context } ) => { const { clientProps : { actions , targetKey } } = context const targets = Context . getTargetsOfType ( context , objectType ) if ( targets . length === 0 ) { return } Dialogs . show ( { component : DeletePet , props : { targets , actions , attribute , isItem : false , selectionKey : targetKey , } } ) } } } File DeletePet.jsx /* eslint-disable no-await-in-loop */ import React from 'react' import { DataSources } from '@leverege/ui-attributes' import { GlobalState , Selection } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' /** * Removes the userIds from the given action. */ async function onRemove ( { data } ) { // Get parameters const { targets , selectionKey , onClose } = data const num = targets . length if ( num === 0 ) { onClose () return } // Try to remove users let success = 0 let failure = 0 let err = null for ( let n = 0 ; n < num ; n ++ ) { try { const tgt = targets [ n ] const actions = DataSources . getActions ( tgt ) await GlobalState . dispatch ( actions . delete () ) success ++ if ( selectionKey ) { GlobalState . dispatch ( Selection . remove ( selectionKey , tgt . id ) ) } } catch ( error ) { failure ++ if ( err == null ) { err = error } // eslint-disable-next-line no-console console . error ( error ) } } // Successfully removed if ( failure === 0 ) { Toast . success ( ` ${ success === 1 ? '' : num } Pet ${ num === 1 ? '' : 's' } Deleted` ) } else if ( success === 0 ) { Toast . error ( [ `Failed to Delete ${ failure === 1 ? '' : num } Pet` , err . message ] ) } else { Toast . warn ( [ `Deleted ${ success } / ${ num } Pet. Failed to delete ${ failure } .` , err . message ] ) } onClose () } /** * Remove users dialog. */ export default function DeletePet ( props ) { // Get parameters const { onClose , show , targets } = props const num = targets ? . length || 0 const title = num < 2 ? 'Pet' : ` ${ num } Pets` const button = 'Delete' const titleType = 'Delete' const extra = `This will permanently delete the ${ title } and cannot be undone.` // Render component return ( < Dialog . Question show = { show } eventData = { props } title = { ` ${ titleType } ${ title } ?` } message = { `Are you sure you want to DELETE ${ num } Pet ${ num === 1 ? '' : 's' } ? ${ extra } ` } okay = { button } okayVariant = \"primaryDestructive\" onCancel = { onClose } onOkay = { onRemove } /> ) }","title":"Delete Action"},{"location":"docs/custom-data/molten-actions/#setup","text":"File PluginSetup.js import DeleteAction from './DeleteAction' import CreateAction from './CreateAction' import UpdateAction from './UpdateAction' import Relationship from '../../../src/dataSource/Relationship' const objectType = 'petApi.pet' const name = 'Pet' const namePlural = 'Pets' exports . install = ( molten ) => { const relationship = new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' , } ) molten . addPlugin ( 'Action' , DeleteAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , CreateAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , UpdateAction ( relationship , { objectType , name , namePlural } ) ) }","title":"Setup"},{"location":"docs/custom-data/routes/","text":"Once you have actions, a dataSource, and ui-attributes, the next step is to create a screen. For this example we intend to re-use the GroupScreen. Using GroupScreen \u00b6 If you've been following along so far, using the GroupScreen is easy! All of the hard work came from the implementation of your DataSource and Action classes earlier. Assuming you stuck to the interface as specified previously, all you have to do to use the GroupScreen is include it as the component in your route (seen in the next step), and pass it the right props, namely: objectType - in this case petApi.pet, but just the type you picked for you items relationship - an instance of the Relationship class from molten actions - an instance of your PetsActions class from before This will look like this: const props = { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () } Installing the Route \u00b6 Route s are another type of plugin, and have several required keys. The Pets Screen Route plugin looks like this: { // all plugins need a unique id id : 'pets.route.PetScreen' , // what is the url of the route? This will be prefixed in the final ui // by the molten baseRoute, which may include additional information like // systemId and person path : '/pets/' , // whether or not the path has to be an exact match to render exact : true , // where in the ui the route will go. This means it // will be rendered at the route inside the Main Screen. // This is common for root level ui screens. matches : { client : 'Main' }, // what React component is rendered by the route (this is the molten GroupScreen) component : GroupScreen , // what props should be passed to the GroupScreen props : { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () } } and is installed like so: molten . addPlugin ( 'Route' , PetRoute ) Of course without a way to get to that route in the ui, its not particularly useful! The best way to install a link to your new pet shop route is with a LinkAction, which can be created and installed like so: // this import is different when working from the molten demo folder import { LinkAction } from '@leverege/molten/lib/routes' const PetLink = LinkAction . create ( { id : 'pet.PetsLink' , matches : { use : 'navBar' , client : 'Main' }, name : 'Pets' , icon : 'fa fa-bug fa-fw' , path : '/pets' } ) molten . addPlugin ( 'Action' , PetLink )","title":"Creating a Route"},{"location":"docs/custom-data/routes/#using-groupscreen","text":"If you've been following along so far, using the GroupScreen is easy! All of the hard work came from the implementation of your DataSource and Action classes earlier. Assuming you stuck to the interface as specified previously, all you have to do to use the GroupScreen is include it as the component in your route (seen in the next step), and pass it the right props, namely: objectType - in this case petApi.pet, but just the type you picked for you items relationship - an instance of the Relationship class from molten actions - an instance of your PetsActions class from before This will look like this: const props = { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () }","title":"Using GroupScreen"},{"location":"docs/custom-data/routes/#installing-the-route","text":"Route s are another type of plugin, and have several required keys. The Pets Screen Route plugin looks like this: { // all plugins need a unique id id : 'pets.route.PetScreen' , // what is the url of the route? This will be prefixed in the final ui // by the molten baseRoute, which may include additional information like // systemId and person path : '/pets/' , // whether or not the path has to be an exact match to render exact : true , // where in the ui the route will go. This means it // will be rendered at the route inside the Main Screen. // This is common for root level ui screens. matches : { client : 'Main' }, // what React component is rendered by the route (this is the molten GroupScreen) component : GroupScreen , // what props should be passed to the GroupScreen props : { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () } } and is installed like so: molten . addPlugin ( 'Route' , PetRoute ) Of course without a way to get to that route in the ui, its not particularly useful! The best way to install a link to your new pet shop route is with a LinkAction, which can be created and installed like so: // this import is different when working from the molten demo folder import { LinkAction } from '@leverege/molten/lib/routes' const PetLink = LinkAction . create ( { id : 'pet.PetsLink' , matches : { use : 'navBar' , client : 'Main' }, name : 'Pets' , icon : 'fa fa-bug fa-fw' , path : '/pets' } ) molten . addPlugin ( 'Action' , PetLink )","title":"Installing the Route"},{"location":"docs/custom-data/search/","text":"If optionally you wish to add the ability for users to free text search your list of items (and your API supports such functionality), you can add just a couple of plugins to do so. The first thing you need to add is a SearchBar plugin, which will look something like this: SearchBar Plugin installation \u00b6 A SearchBar at its core is a DataViewer, so it's installed using that plugin type, but specifically tuned to be used as a search plugin on GroupScreen's molten . addPlugin ( 'DataViewer' , { id : 'molten.dataViewer.search.PetSearchBar' , type : 'molten.Search' , name : 'Search Bar' , icon : 'fa fa-search fa-fw' , // this is what tells the GroupScreen where to put this plugin location : [ 'search' ], // this search bar can only be used against group screens of petApi.pet's matches : { type : 'GroupDataViewer' , objectType : 'petApi.pet' }, component : SearchBar , } ) SearchBar Component \u00b6 For the ease of the pet shop demo, we opted to use the SearchBar from molten, and simply wrap it to adjust some of its props import React from 'react' import ResponsiveSearchBar from '../../../src/screens/group/search/SearchBar' export default function SearchBar ( props ) { const { objectType , path } = props const client = 'molten.group.SearchBar' // changing the use prevents Imagine API suggestions from being rendered, which would break const suggestionsMatchContext = { use : 'petApi.suggestions' , client , objectType , path } return < ResponsiveSearchBar {... props } suggestionsMatchContext = { suggestionsMatchContext } /> } Suggestions Plugin Installation \u00b6 SearchSuggesters are a specialized plugin that allows you to tack additional suggestions onto any search bar (not just the pet shop one!) molten . addPlugin ( 'SearchSuggester' , { id : 'petApi.Suggestions' , name : 'API Suggestions' , // NOTE: this use matches the use from the SearchBar component suggestionsMatchContext matches : { use : 'petApi.suggestions' , client : 'molten.group.SearchBar' }, handles : () => true , // could be useful for storing recent searches onSearchChange : ( { search } ) => {}, suggestions : Suggestions } ) Suggestions Component \u00b6 This component as a note is very similar to the ApiSuggestions in the molten library, but with some changes to make it work with the pet shop example. Get Suggestions Function \u00b6 import { GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' import Path from '@leverege/path' import { Config } from '@leverege/plugin' import Model from '../../../src/screens/group/search/filter/GroupedTextFilterModel' const getSuggestions = async ( actions , filter , search , objectType , api ) => { const f = filter const res = await GlobalState . dispatch ( actions . search ( { filter : f ? { ... f , value : Model . toImagineValue ( search , filter , objectType ) } : null , limit : 100 }, { queryName : 'searchSuggestions' } ) ) const items = {} const toCheck = Model . getLastToken ( search ). toLowerCase () if ( f ? . fields && f . fields . length > 0 ) { f . fields . forEach ( ( field ) => { let accessor = () => null if ( typeof field === 'string' ) { accessor = Path ( field ) } else if ( typeof field === 'object' && field ? . field ) { accessor = Path ( field . field ) } res ? . items . forEach ( ( i ) => { const val = accessor . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } else { const attrs = Attributes . getAttributesFor ( objectType ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . items . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } return Object . keys ( items ) } const updateSuggestions = ( opts ) => { const { actions , filterModel , search , objectType } = opts const filter = Model . toImagineFilter ( filterModel , objectType ) if ( ! search || Model . getLastToken ( search ). length < Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) ) { opts . setItems ( [] ) return Promise . resolve ( [] ) } // do this so we can get at the raw api object and not touch api-redux return new Promise ( ( resolve ) => { process . nextTick ( GlobalState . dispatch , async ( dispatch , getState , { api } ) => { const items = await getSuggestions ( actions , filter , search , objectType , api ) opts . setItems ( items ) resolve ( items ) } ) } ) } export { updateSuggestions , getSuggestions } Suggestion Component \u00b6 import React from 'react' import Suggestion from '../../../src/screens/group/search/suggestions/Suggestion' // an individual suggestion export default function PetSuggestion ( props ) { const { item , search } = props const match = item ? . toLowerCase (). lastIndexOf ( search ? . toLowerCase () ) if ( ! item || match < 0 || item ? . toLowerCase () === search ? . toLowerCase () || search ? . toLowerCase (). endsWith ( item ? . toLowerCase () ) ) { return null } const contents = ( <> { item . slice ( 0 , match )} < b > { item . slice ( match , match + search . length )} < /b> { item . slice ( match + search . length )} < /> ) return ( < Suggestion {... props } newSearch = { item } contents = { contents } /> ) } Suggestions Component \u00b6 import React from 'react' import { Config } from '@leverege/plugin' import Suggestion from './Suggestion' import Suggestions from '../../../src/screens/group/search/suggestions/Suggestions' import { updateSuggestions } from './Util' const searchLongEnough = ( search ) => { return search ? . length >= Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) } // a list of suggestions export default function PetSuggestions ( props ) { return ( < Suggestions {... props } updateSuggestions = { updateSuggestions } searchLongEnough = { searchLongEnough } suggestionClass = { Suggestion } minSuggestionLength = { Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 )} searchDebounceMs = { Config . get ( 'ApiSuggestions' , 'searchDebounceMs' , 100 )} /> ) }","title":"Customizing Search"},{"location":"docs/custom-data/search/#searchbar-plugin-installation","text":"A SearchBar at its core is a DataViewer, so it's installed using that plugin type, but specifically tuned to be used as a search plugin on GroupScreen's molten . addPlugin ( 'DataViewer' , { id : 'molten.dataViewer.search.PetSearchBar' , type : 'molten.Search' , name : 'Search Bar' , icon : 'fa fa-search fa-fw' , // this is what tells the GroupScreen where to put this plugin location : [ 'search' ], // this search bar can only be used against group screens of petApi.pet's matches : { type : 'GroupDataViewer' , objectType : 'petApi.pet' }, component : SearchBar , } )","title":"SearchBar Plugin installation"},{"location":"docs/custom-data/search/#searchbar-component","text":"For the ease of the pet shop demo, we opted to use the SearchBar from molten, and simply wrap it to adjust some of its props import React from 'react' import ResponsiveSearchBar from '../../../src/screens/group/search/SearchBar' export default function SearchBar ( props ) { const { objectType , path } = props const client = 'molten.group.SearchBar' // changing the use prevents Imagine API suggestions from being rendered, which would break const suggestionsMatchContext = { use : 'petApi.suggestions' , client , objectType , path } return < ResponsiveSearchBar {... props } suggestionsMatchContext = { suggestionsMatchContext } /> }","title":"SearchBar Component"},{"location":"docs/custom-data/search/#suggestions-plugin-installation","text":"SearchSuggesters are a specialized plugin that allows you to tack additional suggestions onto any search bar (not just the pet shop one!) molten . addPlugin ( 'SearchSuggester' , { id : 'petApi.Suggestions' , name : 'API Suggestions' , // NOTE: this use matches the use from the SearchBar component suggestionsMatchContext matches : { use : 'petApi.suggestions' , client : 'molten.group.SearchBar' }, handles : () => true , // could be useful for storing recent searches onSearchChange : ( { search } ) => {}, suggestions : Suggestions } )","title":"Suggestions Plugin Installation"},{"location":"docs/custom-data/search/#suggestions-component","text":"This component as a note is very similar to the ApiSuggestions in the molten library, but with some changes to make it work with the pet shop example.","title":"Suggestions Component"},{"location":"docs/custom-data/search/#get-suggestions-function","text":"import { GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' import Path from '@leverege/path' import { Config } from '@leverege/plugin' import Model from '../../../src/screens/group/search/filter/GroupedTextFilterModel' const getSuggestions = async ( actions , filter , search , objectType , api ) => { const f = filter const res = await GlobalState . dispatch ( actions . search ( { filter : f ? { ... f , value : Model . toImagineValue ( search , filter , objectType ) } : null , limit : 100 }, { queryName : 'searchSuggestions' } ) ) const items = {} const toCheck = Model . getLastToken ( search ). toLowerCase () if ( f ? . fields && f . fields . length > 0 ) { f . fields . forEach ( ( field ) => { let accessor = () => null if ( typeof field === 'string' ) { accessor = Path ( field ) } else if ( typeof field === 'object' && field ? . field ) { accessor = Path ( field . field ) } res ? . items . forEach ( ( i ) => { const val = accessor . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } else { const attrs = Attributes . getAttributesFor ( objectType ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . items . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } return Object . keys ( items ) } const updateSuggestions = ( opts ) => { const { actions , filterModel , search , objectType } = opts const filter = Model . toImagineFilter ( filterModel , objectType ) if ( ! search || Model . getLastToken ( search ). length < Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) ) { opts . setItems ( [] ) return Promise . resolve ( [] ) } // do this so we can get at the raw api object and not touch api-redux return new Promise ( ( resolve ) => { process . nextTick ( GlobalState . dispatch , async ( dispatch , getState , { api } ) => { const items = await getSuggestions ( actions , filter , search , objectType , api ) opts . setItems ( items ) resolve ( items ) } ) } ) } export { updateSuggestions , getSuggestions }","title":"Get Suggestions Function"},{"location":"docs/custom-data/search/#suggestion-component","text":"import React from 'react' import Suggestion from '../../../src/screens/group/search/suggestions/Suggestion' // an individual suggestion export default function PetSuggestion ( props ) { const { item , search } = props const match = item ? . toLowerCase (). lastIndexOf ( search ? . toLowerCase () ) if ( ! item || match < 0 || item ? . toLowerCase () === search ? . toLowerCase () || search ? . toLowerCase (). endsWith ( item ? . toLowerCase () ) ) { return null } const contents = ( <> { item . slice ( 0 , match )} < b > { item . slice ( match , match + search . length )} < /b> { item . slice ( match + search . length )} < /> ) return ( < Suggestion {... props } newSearch = { item } contents = { contents } /> ) }","title":"Suggestion Component"},{"location":"docs/custom-data/search/#suggestions-component_1","text":"import React from 'react' import { Config } from '@leverege/plugin' import Suggestion from './Suggestion' import Suggestions from '../../../src/screens/group/search/suggestions/Suggestions' import { updateSuggestions } from './Util' const searchLongEnough = ( search ) => { return search ? . length >= Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) } // a list of suggestions export default function PetSuggestions ( props ) { return ( < Suggestions {... props } updateSuggestions = { updateSuggestions } searchLongEnough = { searchLongEnough } suggestionClass = { Suggestion } minSuggestionLength = { Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 )} searchDebounceMs = { Config . get ( 'ApiSuggestions' , 'searchDebounceMs' , 100 )} /> ) }","title":"Suggestions Component"},{"location":"docs/data-sources/","text":"The purpose of a DataSource plugin is to provide a mechanism by which molten can access data about and acquire \"actions\" against a particular type of object. Data Sources themselves are a @leverege/ui-attributes concept, and more information can be found about them here An example of a fleshed out DataSource class can be found at src/blueprints/dataSource/BlueprintDataSource.js or demo/pets/dataSource/PetDataSource.js","title":"Index"},{"location":"docs/data-viewers/","text":"Data Viewers \u00b6 Danger This is outdated Data Viewers are widgets that are mean to display pieces of information about a common set of data. Usually, this common data is either a list of items (via GroupScreen ) or a single item (via ItemInfoScreen ). The top level controller that manages dataViewers will load the data as needed, but the DataViewers can have some control to effect which data is loaded. In the GroupScreen usage, data viewers are given a filters object by which they can contribute filters. Location \u00b6 DataViewers are presented in a Layout. The root Layout consists of two main sections and four surrounding auxilary sections ( top, bottom, left, right ). These sections are fixed to the screen current screen size, meaning that they do now scroll off the screen: the top is fixed to the top of the area, the bottom to the bottom, left and right to the sides, and the remaining section is divided amoungst the two main sections. Any one of these sections can be null, in which case their space is given to the appropriate section. Within these sections, a Dashboard layout can be created to construct a screen where there are a lot of DataViewers. The dashboard will scroll within its area. A DataViewer can indicate which of this locations they are usable in by specifying an array containing main , aux , or card in their location field. There are also Hidden DataViewers, whose purpose is to load or prepare other data. It should be a viewless component, meaning its render function returns null. Support DataViewers also exist, and implement the same interface. They are meant to be used by other DataViewers and not directly selected for use. To specify a hidden or support DataViewer, set location to be hidden or support . Group Screen \u00b6 Group Data Viewers \u00b6 GroupDataViewers are controlled and organized by the GroupScreen. They will receive the current data, pagination information, filtering information and various keys to help them organize themselves. They can also contribute filters and sort values back to the overall group. Installing \u00b6 To install a plugin, use the following: // Plugins.add( 'GroupDataViewer', ... ) can also be used molten . addPlugin ( 'GroupDataViewer' , { id , type : 'table' , icon : 'fa fa-list fa-fw' , name : 'Table View' , location : 'aux|main|any' , // null => main. Array is also allowed handles : ( relationship ) => { return true } component , createSettings , updateSettings , props : { mode : 1 } } ) Prop Type Description id string The unique plugin id type string The unique type of the DataViewer. icon string The url or font icon class name of the image used to represent the icon. name string The human readable name of the plugin location string Where the DataViewer is usable. primary means only the main sections, where they components must fill 100% of width and height. aux means only the header sections, where based on the vertical prop, the component should take up 100% of width or height, but not both. The other axis should be limited (and relatively small). This is meant for aggregations, rollups, extra command bars, etc. If left null, this will mean primary . If a component can be both, any can be specified. The value of the vertical prop will be undefined when it is used in a primary capacity. handles function A function that takes a relationship object and returns true if the DataViewer can function with the data. component React A react component props object An options object that will be given to the component Props \u00b6 The GroupScreen will supply the following as props to each DataViewers Prop Type Description dispatch object The redux dispatch match object The connected react router match object location object The connected react router location object history object The connected react router history object profile object The current users profile objectType string The object type, which is the blueprint's alias or id data object The current data. The data.items maybe sparce if multiple non-sequential pages have been loaded. Use the pagination to access a single page. The values in data are relationship object The relationship object for current viewed group of data actons object An object used to request creations, delections, etc from the server. The actions should be dispatched. filter object The FilterSourceModel contributed by this data screen filterName string The name of the FilterSourceModel in the FilterSourcesModel. This should be supplied as the 'data' filed in the onFilterChange() event. onFilterChange function Invoke this when the data screen wishes to change its contribution to the filter and sort. The argument should be an event contining filters object The FilterSourcesModel selectionKey string The key used with Selections to manage objects that are selected rolloverKey string The key used with Selections to manage objects that are rolled over targetKey string The key used with Selections to manage objects that are targeted settingsPath string The path used with UserSettings to save data. paginator object The object used to manage pagination. vertical boolean If the DataViewer is used in a header/footer capacity, this will indicate the direction the component will be layed out. This is undefined for primary DataViewers. Hidden Group Screen Viewers \u00b6 Occasionally it is useful to have a group screen viewer installed at a path which does not render any visible UI but which still has the ability to contribute things like filters to the group screen. This can be accomplished by registering a GroupDataViewer with the location of 'hidden'. You can also add a 'matches' property to this plugin which will allow you to only render your hidden viewer for certain paths,object types, etc. The name and icon properties of the GroupDataViewer become unnecessary in this context. NOTE: As a matter of convention, your hidden component should return null from its function body or render method. However, your component will also be wrapped in a display: none; div and will not be visible For example: molten.addPlugin( 'GroupDataViewer', { type : 'ghost', location : 'hidden', matches : { objectType : 'cow' }, handles : () => true, component : HiddenTest, props : { dude : 'Sweet!' } } ) This plugin will render for all pages with objectType === 'cow' and will be passed its own set of filters, etc which it can use to contribute to the group screen. see demo/dataViewer/PluginSetup.js for a working example","title":"Data Viewers"},{"location":"docs/data-viewers/#data-viewers","text":"Danger This is outdated Data Viewers are widgets that are mean to display pieces of information about a common set of data. Usually, this common data is either a list of items (via GroupScreen ) or a single item (via ItemInfoScreen ). The top level controller that manages dataViewers will load the data as needed, but the DataViewers can have some control to effect which data is loaded. In the GroupScreen usage, data viewers are given a filters object by which they can contribute filters.","title":"Data Viewers"},{"location":"docs/data-viewers/#location","text":"DataViewers are presented in a Layout. The root Layout consists of two main sections and four surrounding auxilary sections ( top, bottom, left, right ). These sections are fixed to the screen current screen size, meaning that they do now scroll off the screen: the top is fixed to the top of the area, the bottom to the bottom, left and right to the sides, and the remaining section is divided amoungst the two main sections. Any one of these sections can be null, in which case their space is given to the appropriate section. Within these sections, a Dashboard layout can be created to construct a screen where there are a lot of DataViewers. The dashboard will scroll within its area. A DataViewer can indicate which of this locations they are usable in by specifying an array containing main , aux , or card in their location field. There are also Hidden DataViewers, whose purpose is to load or prepare other data. It should be a viewless component, meaning its render function returns null. Support DataViewers also exist, and implement the same interface. They are meant to be used by other DataViewers and not directly selected for use. To specify a hidden or support DataViewer, set location to be hidden or support .","title":"Location"},{"location":"docs/data-viewers/#group-screen","text":"","title":"Group Screen"},{"location":"docs/data-viewers/#group-data-viewers","text":"GroupDataViewers are controlled and organized by the GroupScreen. They will receive the current data, pagination information, filtering information and various keys to help them organize themselves. They can also contribute filters and sort values back to the overall group.","title":"Group Data Viewers"},{"location":"docs/data-viewers/#installing","text":"To install a plugin, use the following: // Plugins.add( 'GroupDataViewer', ... ) can also be used molten . addPlugin ( 'GroupDataViewer' , { id , type : 'table' , icon : 'fa fa-list fa-fw' , name : 'Table View' , location : 'aux|main|any' , // null => main. Array is also allowed handles : ( relationship ) => { return true } component , createSettings , updateSettings , props : { mode : 1 } } ) Prop Type Description id string The unique plugin id type string The unique type of the DataViewer. icon string The url or font icon class name of the image used to represent the icon. name string The human readable name of the plugin location string Where the DataViewer is usable. primary means only the main sections, where they components must fill 100% of width and height. aux means only the header sections, where based on the vertical prop, the component should take up 100% of width or height, but not both. The other axis should be limited (and relatively small). This is meant for aggregations, rollups, extra command bars, etc. If left null, this will mean primary . If a component can be both, any can be specified. The value of the vertical prop will be undefined when it is used in a primary capacity. handles function A function that takes a relationship object and returns true if the DataViewer can function with the data. component React A react component props object An options object that will be given to the component","title":"Installing"},{"location":"docs/data-viewers/#props","text":"The GroupScreen will supply the following as props to each DataViewers Prop Type Description dispatch object The redux dispatch match object The connected react router match object location object The connected react router location object history object The connected react router history object profile object The current users profile objectType string The object type, which is the blueprint's alias or id data object The current data. The data.items maybe sparce if multiple non-sequential pages have been loaded. Use the pagination to access a single page. The values in data are relationship object The relationship object for current viewed group of data actons object An object used to request creations, delections, etc from the server. The actions should be dispatched. filter object The FilterSourceModel contributed by this data screen filterName string The name of the FilterSourceModel in the FilterSourcesModel. This should be supplied as the 'data' filed in the onFilterChange() event. onFilterChange function Invoke this when the data screen wishes to change its contribution to the filter and sort. The argument should be an event contining filters object The FilterSourcesModel selectionKey string The key used with Selections to manage objects that are selected rolloverKey string The key used with Selections to manage objects that are rolled over targetKey string The key used with Selections to manage objects that are targeted settingsPath string The path used with UserSettings to save data. paginator object The object used to manage pagination. vertical boolean If the DataViewer is used in a header/footer capacity, this will indicate the direction the component will be layed out. This is undefined for primary DataViewers.","title":"Props"},{"location":"docs/data-viewers/#hidden-group-screen-viewers","text":"Occasionally it is useful to have a group screen viewer installed at a path which does not render any visible UI but which still has the ability to contribute things like filters to the group screen. This can be accomplished by registering a GroupDataViewer with the location of 'hidden'. You can also add a 'matches' property to this plugin which will allow you to only render your hidden viewer for certain paths,object types, etc. The name and icon properties of the GroupDataViewer become unnecessary in this context. NOTE: As a matter of convention, your hidden component should return null from its function body or render method. However, your component will also be wrapped in a display: none; div and will not be visible For example: molten.addPlugin( 'GroupDataViewer', { type : 'ghost', location : 'hidden', matches : { objectType : 'cow' }, handles : () => true, component : HiddenTest, props : { dude : 'Sweet!' } } ) This plugin will render for all pages with objectType === 'cow' and will be passed its own set of filters, etc which it can use to contribute to the group screen. see demo/dataViewer/PluginSetup.js for a working example","title":"Hidden Group Screen Viewers"},{"location":"docs/routes/","text":"Adding a Screen \u00b6 Molten will by default, analyze your Imagine project's Blueprints and create Screens and Routes to the screens based off of their hierarchies. Custom Screens can be added, however. There are normally three parts to this process: creation of the Screen component, registering a Route to a URL, and making a Link to take the user to the URL. Molten uses React Router and Plugins define which screens are presented at a particular URL. The screen presented at a URL may actually be composed of several subscreens, depending on how the Routes are specific. For example, a URL of /Group/5/Children may actually present a screen for Group/5 , which has some links, widgets, information, etc, but also has a Dynamic Route mechanism it it that would also present the Children screen. Route Plugins are evaluated and installed when the getRoutesFor() call is invoked. This can occur in multiple screens in your application. The DesktopMainScreen , for example calls: <Switch> {Routes.getRoutesFor( 'Main', null, { client : 'Main' } )} </Switch> This is asking for all Routes that wish to be installed at the 'Main' client level. Route Plugins should specify a matches object that indicates where it wishes to be installed.","title":"Adding a Screen"},{"location":"docs/routes/#adding-a-screen","text":"Molten will by default, analyze your Imagine project's Blueprints and create Screens and Routes to the screens based off of their hierarchies. Custom Screens can be added, however. There are normally three parts to this process: creation of the Screen component, registering a Route to a URL, and making a Link to take the user to the URL. Molten uses React Router and Plugins define which screens are presented at a particular URL. The screen presented at a URL may actually be composed of several subscreens, depending on how the Routes are specific. For example, a URL of /Group/5/Children may actually present a screen for Group/5 , which has some links, widgets, information, etc, but also has a Dynamic Route mechanism it it that would also present the Children screen. Route Plugins are evaluated and installed when the getRoutesFor() call is invoked. This can occur in multiple screens in your application. The DesktopMainScreen , for example calls: <Switch> {Routes.getRoutesFor( 'Main', null, { client : 'Main' } )} </Switch> This is asking for all Routes that wish to be installed at the 'Main' client level. Route Plugins should specify a matches object that indicates where it wishes to be installed.","title":"Adding a Screen"},{"location":"docs/routes/links/","text":"Links \u00b6 Links to a Screen can be done in many ways. Any standard component can change the URL when told to do so by the user. In the case of the default Molten Desktop Screen, toolbars are install to allow th user to put custom actions to perform a variety of commands such as logging out, changing persona, bring up a dialog, or going to a URL. To got to our new Route and Screen using the toolbars, we can use the LinkAction.create() to create an action that will integrate with the existing menus. The following options can be given to the create function: Field Type Description id String The unique plugin id matches Object An object specifying where the the Action should appear. Normally, the client is specified and in come cases an even finer criteria layout Object The Plugins Layout object that can specify where the action should appear, including submenuing, section names and sorting. See Layout path String The URL path to take the user to name String or funciton The name of string to show the user icon String The font icon or url to use as an icon for the action iconOn String The font icon or url to use as an icon for the action when the user is at the path. iconOff String The font icon or url to use as an icon for the action when the user is not at the path handles function The action handles method that can be used to further refined if this action is visible Example \u00b6 Plugin Setup File IncredibleLink.js . export default LinkAction . create ( { id : 'my.link.IncredibleScreen' , matches : { use : 'userBar' , client : 'Main' }, name : 'Incredible' , icon : 'fa fa-snowflake-o fa-fw' , path : '/iscreen' } ) In this case, we are going to put the link to /iscreen into the Main Screen's user profile toolbar (targeted by using use : \"userBar\" ) with the name \"Incredible\" and a snowfake icon. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Action' , IncredibleLink ) }","title":"Links"},{"location":"docs/routes/links/#links","text":"Links to a Screen can be done in many ways. Any standard component can change the URL when told to do so by the user. In the case of the default Molten Desktop Screen, toolbars are install to allow th user to put custom actions to perform a variety of commands such as logging out, changing persona, bring up a dialog, or going to a URL. To got to our new Route and Screen using the toolbars, we can use the LinkAction.create() to create an action that will integrate with the existing menus. The following options can be given to the create function: Field Type Description id String The unique plugin id matches Object An object specifying where the the Action should appear. Normally, the client is specified and in come cases an even finer criteria layout Object The Plugins Layout object that can specify where the action should appear, including submenuing, section names and sorting. See Layout path String The URL path to take the user to name String or funciton The name of string to show the user icon String The font icon or url to use as an icon for the action iconOn String The font icon or url to use as an icon for the action when the user is at the path. iconOff String The font icon or url to use as an icon for the action when the user is not at the path handles function The action handles method that can be used to further refined if this action is visible","title":"Links"},{"location":"docs/routes/links/#example","text":"Plugin Setup File IncredibleLink.js . export default LinkAction . create ( { id : 'my.link.IncredibleScreen' , matches : { use : 'userBar' , client : 'Main' }, name : 'Incredible' , icon : 'fa fa-snowflake-o fa-fw' , path : '/iscreen' } ) In this case, we are going to put the link to /iscreen into the Main Screen's user profile toolbar (targeted by using use : \"userBar\" ) with the name \"Incredible\" and a snowfake icon. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Action' , IncredibleLink ) }","title":"Example"},{"location":"docs/routes/routes/","text":"Routes \u00b6 The Routes defines what to render, where. The what is a React component, and the where is a URL. The route is a directive to tell Molten to render a particular React component at a mathcing url pattern when certain criteria are met. The criteria is captured in the matches object defined by the plugin, and follows the rules of the Plugin Matches system. To define a Route, add a Route Plugin that has the following properties: Field Type Description id String The unique plugin id exact boolean If true , the URL must match exactly the path. This should be true in the case of a leaf screen, false in the case where the screen manages deeper parts of the url. For example, our /Group/5 screen above would set this to false and then render its own Switch Component useing the Routes object. path String or Array The path expression used to match eg. /group/:groupId matches Object An object specifying where the the route should appear. Normally, the client is specified component ReactComponent or Function The component to render render function Optional React function to render props Object or null Extra props to send into the component. These can be overriden by extra props sent into the getRoutesFor function strict boolean If true, the path will compare trailing slashes Example \u00b6 Plugin Setup File IncredibleRoute.js . export default { id : 'my.route.IncredibleScreen' , exact : true , path : '/iscreen/' , matches : { client : 'Main' }, component : IncredibleScreen , props : { hello : 'world' } } This plugin is asking Molten to render the IncredibleScreen when the URL path is exactly /iscreen/ . It will only be matched at the top level Switch, managed by the Main client. Extra prop will be given to the screen. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Route' , IncredibleRoute ) } Dynamic Plugin Addition \u00b6 The Routing mechanism is listening for changes to the routes, so Routes added during execution will be used the next time the Switch/getRoutesFor() is called. The order in which the plugins are added does not matter. The order in which Routes are returned are based on a specificity. Sorting Paths The routes are turned into strings of 'A's, 'C's, 'E's and 'R's, where 'A' are explicit path components, and 'C's are variable (changeable) parameters, 'E's are extact match and 'R's indicates the rest matches too. These will then be sorted first by length, then by string sort on the ACER strings.","title":"Routes"},{"location":"docs/routes/routes/#routes","text":"The Routes defines what to render, where. The what is a React component, and the where is a URL. The route is a directive to tell Molten to render a particular React component at a mathcing url pattern when certain criteria are met. The criteria is captured in the matches object defined by the plugin, and follows the rules of the Plugin Matches system. To define a Route, add a Route Plugin that has the following properties: Field Type Description id String The unique plugin id exact boolean If true , the URL must match exactly the path. This should be true in the case of a leaf screen, false in the case where the screen manages deeper parts of the url. For example, our /Group/5 screen above would set this to false and then render its own Switch Component useing the Routes object. path String or Array The path expression used to match eg. /group/:groupId matches Object An object specifying where the the route should appear. Normally, the client is specified component ReactComponent or Function The component to render render function Optional React function to render props Object or null Extra props to send into the component. These can be overriden by extra props sent into the getRoutesFor function strict boolean If true, the path will compare trailing slashes","title":"Routes"},{"location":"docs/routes/routes/#example","text":"Plugin Setup File IncredibleRoute.js . export default { id : 'my.route.IncredibleScreen' , exact : true , path : '/iscreen/' , matches : { client : 'Main' }, component : IncredibleScreen , props : { hello : 'world' } } This plugin is asking Molten to render the IncredibleScreen when the URL path is exactly /iscreen/ . It will only be matched at the top level Switch, managed by the Main client. Extra prop will be given to the screen. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Route' , IncredibleRoute ) }","title":"Example"},{"location":"docs/routes/routes/#dynamic-plugin-addition","text":"The Routing mechanism is listening for changes to the routes, so Routes added during execution will be used the next time the Switch/getRoutesFor() is called. The order in which the plugins are added does not matter. The order in which Routes are returned are based on a specificity. Sorting Paths The routes are turned into strings of 'A's, 'C's, 'E's and 'R's, where 'A' are explicit path components, and 'C's are variable (changeable) parameters, 'E's are extact match and 'R's indicates the rest matches too. These will then be sorted first by length, then by string sort on the ACER strings.","title":"Dynamic Plugin Addition"},{"location":"docs/routes/screens/","text":"Screens \u00b6 A Screen is just a React Component. It can pretty much do what it wants. It can connect to Redux, it can call external APIs, it can use its own custom Plugins, it can other Plugins mechanism that already exist such as attributes or toolbars, it can use Routes.getRoutesFor() to have its own sub registered Routes/Screens with a custom navigation mechanism. The only real consideration is that the screen will be given an area to render in, and it should manage it own rendering and scroll areas. This is good place to use ui-elements' Content , but other mechanism can work as well. React Components We highly recommend using @leverege/ui-elements for your components, as they will inherit the theme used for the rest of the screens. You can also use the css variables that the theme exports to aid with this theme consistency if using the ui-elements library is not feasible. Example \u00b6 In the following example, our IncredibleScreen will have a title bar, and action toolbar to accept plugins, and a greeting. File IncredibleRoute.js . import React from 'react' import { connect } from 'react-redux' import { Text , Content } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import { TitleBar , Toolbar } from '@leverege/ui-plugin' class IncredibleScreen extends React . Component { render () { const { hello = '-' } = this . props // Putting welcome into the matchContext for the // tool bar is not required, but would all actions // to only appear if welcome is a certain value this . matchContext = { client : 'IncredibleScreen' , welcome : hello } return ( < Content > < Content . Header > < TitleBar variant = \"screenTitle\" title = \"Incredible Screen\" icon = { Config . get ( 'IncredibleScreen' , 'screenIcon' , 'fa fa-snowflake-o fa-fw' )} > < Toolbar variant = \"actionBar\" prefer = \"icon\" hasContextMenu = { false } matchContext = { this . matchContext } context = {{}} /> < /TitleBar> < /Content.Header> < Content . Area variant = \"screenContent\" > < Text variant = \"caption\" icon = \"fa fa-snowflake fa-fw\" > My incredible Screen ! < /Text> < Text variant = \"smallCaption\" icon = \"fa fa-snowflake fa-fw\" > Hello { hello } ! < /Text> < /Content.Area> < /Content> ) } } export default connect ( state => ( { } ) )( IncredibleScreen )","title":"Screens"},{"location":"docs/routes/screens/#screens","text":"A Screen is just a React Component. It can pretty much do what it wants. It can connect to Redux, it can call external APIs, it can use its own custom Plugins, it can other Plugins mechanism that already exist such as attributes or toolbars, it can use Routes.getRoutesFor() to have its own sub registered Routes/Screens with a custom navigation mechanism. The only real consideration is that the screen will be given an area to render in, and it should manage it own rendering and scroll areas. This is good place to use ui-elements' Content , but other mechanism can work as well. React Components We highly recommend using @leverege/ui-elements for your components, as they will inherit the theme used for the rest of the screens. You can also use the css variables that the theme exports to aid with this theme consistency if using the ui-elements library is not feasible.","title":"Screens"},{"location":"docs/routes/screens/#example","text":"In the following example, our IncredibleScreen will have a title bar, and action toolbar to accept plugins, and a greeting. File IncredibleRoute.js . import React from 'react' import { connect } from 'react-redux' import { Text , Content } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import { TitleBar , Toolbar } from '@leverege/ui-plugin' class IncredibleScreen extends React . Component { render () { const { hello = '-' } = this . props // Putting welcome into the matchContext for the // tool bar is not required, but would all actions // to only appear if welcome is a certain value this . matchContext = { client : 'IncredibleScreen' , welcome : hello } return ( < Content > < Content . Header > < TitleBar variant = \"screenTitle\" title = \"Incredible Screen\" icon = { Config . get ( 'IncredibleScreen' , 'screenIcon' , 'fa fa-snowflake-o fa-fw' )} > < Toolbar variant = \"actionBar\" prefer = \"icon\" hasContextMenu = { false } matchContext = { this . matchContext } context = {{}} /> < /TitleBar> < /Content.Header> < Content . Area variant = \"screenContent\" > < Text variant = \"caption\" icon = \"fa fa-snowflake fa-fw\" > My incredible Screen ! < /Text> < Text variant = \"smallCaption\" icon = \"fa fa-snowflake fa-fw\" > Hello { hello } ! < /Text> < /Content.Area> < /Content> ) } } export default connect ( state => ( { } ) )( IncredibleScreen )","title":"Example"},{"location":"docs/startup/","text":"Startup \u00b6 There are many phases to startup. Plugins are used to drive as many of these as possible. The startup flow looks like: flowchart TB subgraph Providers E[Run Reducer Plugins] --> F[Run Middleware Plugins]; end subgraph Prerender direction LR; PRA[Verify Current User] --> PRB[Load OIDC Clients]; end subgraph OnLogin [Run On Login Plugins ] LA[Role Downloading] --> LB[Blueprint Analysis]; LB --> LC[Custom]; end A[Load Plugins] --> B[Run Initializers Plugins]; B -->C[Run Support Component Plugins]; C --> D[Run Provider Plugins]; D --> Providers; Providers --> Prerender; Prerender --> Auth{Valid User?}; Auth -- Yes --> Render[Render Main React App]; Auth -- No --> Login[Render Login Screen]; Login --> Auth; Render --> OnLogin; click B href \"./initializers/\" \"Run the Initializer Plugins\" _self click C href \"./support-components/\" \"Run the Component Support Plugins\" _self Init Molten This loads the default Plugins Load custom plugins Implemented by custom application Run all Initializer Plugins Run all Support Component Plugins Run all Provider Plugins Reducer Plugins run from ReduxStore plugin Middleware Plugins run from ReduxStore plugin Run all Prerender Plugins Auth verify run by Auth plugin Oidc loaded here to be ready for login screen by Auth plugin Render React application Login/Authentication LoggedIn Plugins run Role downloading Blueprint Analysis Auto plugins created","title":"Startup"},{"location":"docs/startup/#startup","text":"There are many phases to startup. Plugins are used to drive as many of these as possible. The startup flow looks like: flowchart TB subgraph Providers E[Run Reducer Plugins] --> F[Run Middleware Plugins]; end subgraph Prerender direction LR; PRA[Verify Current User] --> PRB[Load OIDC Clients]; end subgraph OnLogin [Run On Login Plugins ] LA[Role Downloading] --> LB[Blueprint Analysis]; LB --> LC[Custom]; end A[Load Plugins] --> B[Run Initializers Plugins]; B -->C[Run Support Component Plugins]; C --> D[Run Provider Plugins]; D --> Providers; Providers --> Prerender; Prerender --> Auth{Valid User?}; Auth -- Yes --> Render[Render Main React App]; Auth -- No --> Login[Render Login Screen]; Login --> Auth; Render --> OnLogin; click B href \"./initializers/\" \"Run the Initializer Plugins\" _self click C href \"./support-components/\" \"Run the Component Support Plugins\" _self Init Molten This loads the default Plugins Load custom plugins Implemented by custom application Run all Initializer Plugins Run all Support Component Plugins Run all Provider Plugins Reducer Plugins run from ReduxStore plugin Middleware Plugins run from ReduxStore plugin Run all Prerender Plugins Auth verify run by Auth plugin Oidc loaded here to be ready for login screen by Auth plugin Render React application Login/Authentication LoggedIn Plugins run Role downloading Blueprint Analysis Auto plugins created","title":"Startup"},{"location":"docs/startup/initializers/","text":"Initializer Plugins \u00b6 The Plugins installed at Constants.INITIALIZER or 'Molten.Initializer' are invoked after as the first step in Molten.create() . These plugins should have an id , sort , and init( molten ) function as properties. This function can be async and the next initializer in the chain will not be called until the one before it finishes. Initializers can initialize objects from the config options ( molten.getConfig() ) and make them available to other steps by calling molten.set( key, value ) or molten.setThunk( key, ) . Example \u00b6 Plugin Setup File MyInitializer.js . export default { id : 'my.Initializer' , sort : - 5 , // defaults to 0, init : ( molten ) => { const api = new Api ( molten . getConfig ( 'api' ) ) molten . set ( 'api' ) molten . setThunkArg ( 'api' , api ) } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.Initializer' , MyInitialize ) Default Initializers \u00b6 The inital Molten setup will install the following plugins as Initializer Plugins. Type Sort Description molten.LoadConfig -1000000 This will take values from config.plugins.config and call Config.set( resource, key, value ). The config.plugins.config should be configured with as { : { : } } molten.Splash -100000 This will create a splash screen based on the config's molten.splashClass , if present. molten.ApiInit -100 This will create an Api object to interface to Leverege's platform and advertise it as a the 'api' thunk argument and the value 'api' in Molten's values. molten.RouterInit -30 Creates a history object and sets it as 'history' in molten's values.","title":"Initializers"},{"location":"docs/startup/initializers/#initializer-plugins","text":"The Plugins installed at Constants.INITIALIZER or 'Molten.Initializer' are invoked after as the first step in Molten.create() . These plugins should have an id , sort , and init( molten ) function as properties. This function can be async and the next initializer in the chain will not be called until the one before it finishes. Initializers can initialize objects from the config options ( molten.getConfig() ) and make them available to other steps by calling molten.set( key, value ) or molten.setThunk( key, ) .","title":"Initializer Plugins"},{"location":"docs/startup/initializers/#example","text":"Plugin Setup File MyInitializer.js . export default { id : 'my.Initializer' , sort : - 5 , // defaults to 0, init : ( molten ) => { const api = new Api ( molten . getConfig ( 'api' ) ) molten . set ( 'api' ) molten . setThunkArg ( 'api' , api ) } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.Initializer' , MyInitialize )","title":"Example"},{"location":"docs/startup/initializers/#default-initializers","text":"The inital Molten setup will install the following plugins as Initializer Plugins. Type Sort Description molten.LoadConfig -1000000 This will take values from config.plugins.config and call Config.set( resource, key, value ). The config.plugins.config should be configured with as { : { : } } molten.Splash -100000 This will create a splash screen based on the config's molten.splashClass , if present. molten.ApiInit -100 This will create an Api object to interface to Leverege's platform and advertise it as a the 'api' thunk argument and the value 'api' in Molten's values. molten.RouterInit -30 Creates a history object and sets it as 'history' in molten's values.","title":"Default Initializers"},{"location":"docs/startup/redux/","text":"Redux here","title":"Redux"},{"location":"docs/startup/support-components/","text":"Support Component Plugins \u00b6 The Plugins installed at Constants.SUPPORT_COMPONENTS or 'Molten.SupportComponent' are invoked just before the Providers. These plugins should have an id , sort , and createSupportComponents( molten ) function as properties. This function should an array of components to be placed beside the Application. Support components like Toast and Dialogs can use this. In the React world, these components are used to install components to support the final app. They are siblings of the Main application and exist within the providers: < X . Provider > < AuthCheckScreen /> < MySypportComponent /> < Toast /> < Dialogs /> < ... other Support Components ... > < /X.Provider> The plugin should have a createSupportComponents( molten ) function that returns an array of support components to install. Example \u00b6 Plugin Setup File MySupportComponent.js . export default { id : 'molten.Theme' , sort : 0 , createSupportComponents : ( molten ) => { return [ React . createElement ( Toast , { key : 'theme.toast' , containerId : 'default' } ), React . createElement ( Dialogs , { key : 'theme.dialogs' } ) ] } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.SupportComponents' , MySupportComponent ) Default Support Components \u00b6 Type Sort Description molten.Theme 0 This will install Toast and Dialogs support","title":"Support Components"},{"location":"docs/startup/support-components/#support-component-plugins","text":"The Plugins installed at Constants.SUPPORT_COMPONENTS or 'Molten.SupportComponent' are invoked just before the Providers. These plugins should have an id , sort , and createSupportComponents( molten ) function as properties. This function should an array of components to be placed beside the Application. Support components like Toast and Dialogs can use this. In the React world, these components are used to install components to support the final app. They are siblings of the Main application and exist within the providers: < X . Provider > < AuthCheckScreen /> < MySypportComponent /> < Toast /> < Dialogs /> < ... other Support Components ... > < /X.Provider> The plugin should have a createSupportComponents( molten ) function that returns an array of support components to install.","title":"Support Component Plugins"},{"location":"docs/startup/support-components/#example","text":"Plugin Setup File MySupportComponent.js . export default { id : 'molten.Theme' , sort : 0 , createSupportComponents : ( molten ) => { return [ React . createElement ( Toast , { key : 'theme.toast' , containerId : 'default' } ), React . createElement ( Dialogs , { key : 'theme.dialogs' } ) ] } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.SupportComponents' , MySupportComponent )","title":"Example"},{"location":"docs/startup/support-components/#default-support-components","text":"Type Sort Description molten.Theme 0 This will install Toast and Dialogs support","title":"Default Support Components"},{"location":"getting-started/","text":"Getting Started \u00b6 Doc index.md","title":"Installation"},{"location":"getting-started/#getting-started","text":"Doc index.md","title":"Getting Started"},{"location":"getting-started/i18n/","text":"Localization \u00b6 i18n.md Installing Bundler \u00b6 Checking for translations \u00b6","title":"Localization"},{"location":"getting-started/i18n/#localization","text":"i18n.md","title":"Localization"},{"location":"getting-started/i18n/#installing-bundler","text":"","title":"Installing Bundler"},{"location":"getting-started/i18n/#checking-for-translations","text":"","title":"Checking for translations"},{"location":"plugins/","text":"Plugins \u00b6 These plugins are automatically installed with Molten.","title":"Plugins"},{"location":"plugins/#plugins","text":"These plugins are automatically installed with Molten.","title":"Plugins"}]}